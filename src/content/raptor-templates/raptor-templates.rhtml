<c:template
    xmlns:c="core"
    xmlns:docs="docs"
    docs:functions="url">
    
    <docs:docs heading="Raptor Templates">
        
        <docs:section heading="Overview">
            <div class="try-it">
                <h1><docs:icon name="play-circle" size="large"/> <a href="${url('/raptor-templates/try-online')}">Try Raptor Templates Online</a></h1>
                <div class="desc">Edit Raptor Templates in your browser with instant results!</div>
            </div>
            
            <p>
                The Raptor Templating Language is heavily inspired by  
                <a href="http://genshi.edgewall.org/wiki/Documentation/xml-templates.html">Genshi XML Template Language</a> 
                (a templating language for Python) with the good parts of JSP mixed in. The Raptor 
                Templating Language borrows most of the same features from Genshi and includes a 
                JavaScript compiler so that a template can be compiled to native JavaScript code.
            </p>
            <p>
                Since the Raptor Templating Language borrows many of the good features of JSP, 
                most templates will look very similar to JSP templates.
            </p>
            
        </docs:section>
        
        <docs:section heading="Introduction">
            <p>
                All Raptor templates are required to be well-formed XML. This
                constraint allows the template language to use the structure of the
                XML document to its advantage. For example, a template directive
                that controls structural logic can be applied as an attribute of the
                element that it controls. In addition, unlike in non-XML-based
                templating languages, whitespace removal rules are based on the XML
                structure and not a string language directives. Despite a template
                being well-formed XML, the output does not have to be well-formed
                XML which makes the Raptor Templating Language flexible enough for
                using in all types of web applications.
            </p>
            <p>
                The Raptor Templating Language aims to be easy to understand by utilizing
                concepts that front-end developers are already familiar with such as
                XML/HTML and JavaScript. While the Raptor Templating Language
                introduces a new grammar on top of XHTML, it is not an entirely new
                language which reduces the learning curve.
            </p>
            
            <docs:section heading="Sample Template">
                <p>
                    Below is a sample Raptor HTML template:
                </p>
<docs:code-editor 
    mode="xml"
    readOnly="true" 
    c:parseBodyText="false"
><![CDATA[<c:template
    xmlns:c="core"
    name="demo"
    params="colors">
 
    <!-- Colors available -->
    <ul c:if="notEmpty(colors)">
        <li c:for="color in colors">
            $color
        </li>
    </ul>
     
    <!-- No colors available -->
    <div c:if="empty(colors)">
        No colors!
    </div>
     
</c:template>]]></docs:code-editor>
                <p>
                </p>
            </docs:section>
            
            <docs:section heading="Template Rendering">
                <p>
                    To produce output, a compiled template
                    is invoked with the provided user data
                    that is required by the template.
                </p>
                <p>
                    For example, given the following input data:
                </p>
<docs:code-editor 
    mode="javascript"
    readOnly="true" 
    c:parseBodyText="false"
><![CDATA[{
    colors: ["red", "green", "blue"]
}]]></docs:code-editor>
                <p>
                    The output of rendering the above sample template would be the following:
                </p>
<docs:code-editor 
    mode="xml"
    readOnly="true" 
    c:parseBodyText="false"
><![CDATA[<ul><li>red</li><li>green</li><li>blue</li></ul>]]></docs:code-editor>
                <p>
                    For comparison, given the following input data consisting of an empty array of colors:
                </p>
<docs:code-editor 
    mode="javascript"
    readOnly="true" 
    c:parseBodyText="false"
><![CDATA[{
    colors: []
}]]></docs:code-editor>
                <p>
                    The output would be the following:
                </p>
<docs:code-editor 
    mode="xml"
    readOnly="true" 
    c:parseBodyText="false"
><![CDATA[<div>No colors!</div>]]></docs:code-editor>
            </docs:section>
            
            <docs:section heading="Template Directives Overview">
                <p>
                    Almost all of the Raptor templating directives can be used as either
                    an attribute or as an element. The template included above can be
                    rewritten to apply template directives as elements instead of as
                    attributes to produce the equivalent output. For example:
                </p>
                <table class="table table-bordered">
                    <thead>
                        <tr>
                            <th>
                                Applying directives using attributes
                            </th>
                            <th>
                                Applying directives using elements
                            </th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td style="width: 50%">
<docs:code-editor 
    mode="xml"
    readOnly="true" 
    c:parseBodyText="false"
><![CDATA[<c:template
    xmlns:c="core"
    name="demo"
    params="colors">
 
    <!-- Colors available -->
    <ul c:if="notEmpty(colors)">
        <li c:for="color in colors">
            $color
        </li>
    </ul>
     
    <!-- No colors available -->
    <div c:if="empty(colors)">
        No colors!
    </div>
     
</c:template>]]></docs:code-editor>
                            </td>
                            <td style="width: 50%">
<docs:code-editor 
    mode="xml"
    readOnly="true" 
    c:parseBodyText="false"
><![CDATA[<c:template
    xmlns:c="core"
    name="demo"
    params="colors">
  
    <!-- Colors available -->
    <c:if test="notEmpty(colors)">
        <ul>
            <c:for each="color in colors">
                <li>
                    $color
                </li>
            </c:for>
        </ul>
    </c:if>
      
    <!-- No colors available -->
    <c:if test="empty(colors)">
        <div>
            No colors!
        </div>
    </c:if>
     
</c:template>]]></docs:code-editor>
                            </td>
                        </tr>
                    </tbody>
                </table>
                
                <p>
                    The disadvantage of using elements to control structural logic is
                    that they change the nesting of the elements which can impact
                    readability. For this reason it is often more suitable to use
                    attributes.
                </p>
            </docs:section>
            
            <docs:section heading="Extensibility">
                <p>
                </p>
            </docs:section>
            
        </docs:section>
        
        <docs:section heading="Expressions">
            <p>
                Valid JavaScript expressions are allowed wherever expressions can be
                used within a template. However, because templates must be
                well-formed XML you will have problems if you try to use unescaped
                less than ("${entity:lt}") and ampersand ("${entity:amp}") characters as part of an
                expression since those characters are special XML characters and
                would break parsing. You can choose to escape the special characters
                (i.e. use "${entity:amp}lt;" for "${entity:lt}" and "${entity:amp}amp;" 
                for "${entity:amp}") or, preferably, you
                can choose to use any of the following equivalent binary operators
                supported by the Raptor Templating Language:
            </p>
            <table class="expression-operators table table-striped table-bordered table-condensed">
                <thead>
                    <tr>
                        <th>JavaScript Operator</th>
                        <th>Raptor Equivalent</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>${entity:amp}${entity:amp}</code></td>
                        <td><code>and</code></td>
                    </tr>
                    <tr>
                        <td><code>||</code></td>
                        <td><code>or</code></td>
                    </tr>
                    <tr>
                        <td><code>===</code></td>
                        <td><code>eq</code></td>
                    </tr>
                    <tr>
                        <td><code>!==</code></td>
                        <td><code>ne</code></td>
                    </tr>
                    <tr>
                        <td><code>${entity:lt}</code></td>
                        <td><code>lt</code></td>
                    </tr>
                    <tr>
                        <td><code>></code></td>
                        <td><code>gt</code></td>
                    </tr>
                    <tr>
                        <td><code>${entity:lt}=</code></td>
                        <td><code>le</code></td>
                    </tr>
                    <tr>
                        <td><code>>=</code></td>
                        <td><code>ge</code></td>
                    </tr>
                </tbody>
            </table>
            
            <docs:section heading="Helper Functions">
                <p>
                    Because expressions in Raptor Templates allow any JavaScript
                    code, expressions can make use of global functions. It 
                    is also possible to import functions provided
                    by taglibs as local variables to avoid the use of
                    global functions. See <a href="#TaglibHelperFunctions">
                        <nobr>Taglibs ${entity:raquo} Helper Functions</nobr> 
                    </a>
                    for more details.
                    
                </p>
            </docs:section>
            
            <docs:section heading="Expression Escape Sequences">
                <p c:parseBodyText="false">
                     If the text "${" is intended to be part of the output then the "$" 
                     character must be escaped using a backslash as shown in the following code:
                </p>
<docs:code-editor 
    mode="xml"
    readOnly="true" 
    c:parseBodyText="false"
><![CDATA[\${test} &lt;!-- Output: ${test} -->]]></docs:code-editor>
                <p c:parseBodyText="false">
                    In the unlikely case that "\${" was intended to be part of the
                    output then the backslash must be escaped by another backslash as
                    shown in the following code:
                </p>
<docs:code-editor 
    mode="xml"
    readOnly="true" 
    c:parseBodyText="false"
><![CDATA[\\${test} &lt;!-- Output: \${test} -->]]></docs:code-editor>
            </docs:section>
            
            <docs:section heading="Expression Handlers">
                <p>
                </p>
            </docs:section>
            
        </docs:section>
        
        <docs:section heading="Template Directives">
            
            <docs:section heading="Template">
                
                <docs:section heading="${startTag:c:template}">
                    <p>
                        The root element of all templates should be a &lt;c:template>
                        tag. This tag defines the name of the template and the input
                        parameters for the template. In addition, XML namespaces
                        corresponding to taglibs should be attached to the root element.
                    </p>
<docs:code-editor 
    mode="xml"
    readOnly="true" 
    c:parseBodyText="false"
><![CDATA[<c:template
    xmlns:c="http://raptorjs.org/templates/core"
    name="greeting"
    params="name,count">
    ...  
</c:template>]]></docs:code-editor>

                    <docs:message type="info">
                        <p>
                            All taglib URIs support a "short name" that can be used as an
                            alternative to a long taglib URI. For example, the short name for
                            "http://raptor.ebayopensource.org/core" is "core". Therefore, the
                            following will work as well:
                        </p>
<docs:code-editor 
    mode="xml"
    readOnly="true" 
    c:parseBodyText="false"
><![CDATA[<c:template
    xmlns:c="core"
    name="greeting"
    params="name,count">
    ...
</c:template>]]></docs:code-editor>
                    </docs:message>
                    
                    <p>
                        The "names" attribute is required and when loaded the template will
                        register itself based on the name provided. The "params" attribute
                        can be used to create one or more local variables using
                        corresponding properties from the provided data object. The params
                        attribute is optional, but if provided, it should consist of a
                        comma-separated list of variable names.
                    </p>
                    
                    <docs:message type="info">
                        <p>
                            The "params" attribute is used to create local variables that can be
                            easily accessed throughout the HTML template. Alternatively,
                            properties of the data object can be accessed directly. The
                            following are equivalent:
                        </p>
                        <table class="table table-bordered">
                            <thead>
                                <tr>
                                    <th>
                                        With params
                                    </th>
                                    <th>
                                        Without params
                                    </th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td style="width: 50%">
<docs:code-editor 
    mode="xml"
    readOnly="true" 
    c:parseBodyText="false"
><![CDATA[<c:template
    xmlns:c="core"
    name="greeting"
    params="name,count">
  
    Hello $name! You have $count new messages.
  
</c:template>]]></docs:code-editor>
                                    </td>
                                    <td style="width: 50%">
<docs:code-editor 
    mode="xml"
    readOnly="true" 
    c:parseBodyText="false"
><![CDATA[<c:template
    xmlns:c="core"
    name="greeting">
  
    Hello ${data.name}! You have ${data.count} new messages.
  
</c:template>]]></docs:code-editor>
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                        <p>
                            The benefit of declaring parameters is that the local variables will
                            be minified which can reduce the size of the compiled output if the
                            variable is used in many places. In addition, declaring params
                            make it easier for other developers to understand what
                            input is expected for a template.
                        </p>
                    </docs:message>
                </docs:section>
                
                <docs:section heading="${startTag:c:include}">
                    <p>
                        Another template can easily be included using the ${entity:lt}c:include>
                        directive. The "template" attribute is required to specify name of
                        the template to include and all other attributes are used as
                        arguments to the template.
                    </p>
<docs:code-editor 
    mode="xml"
    readOnly="true" 
    c:parseBodyText="false"
><![CDATA[<c:include template="myTemplate" someArg="${someVar}" anotherArg="Hello"/>]]></docs:code-editor>
                </docs:section>
                
            </docs:section>
            
            <docs:section heading="Text Replacement">
                <p c:parseBodyText="false">
                    Dynamic text should be of the form ${entity:lt}variable-name> or
                    ${{entity:lt}javascript-expression>}:
                </p>
<docs:code-editor 
    mode="xml"
    readOnly="true" 
    c:parseBodyText="false"
><![CDATA[<div>
    Hello $name!
</div>
<div>
    Hello ${name.toUpperCase()}!
</div>
<img src="$imgUrl"/>]]></docs:code-editor>
                
                <docs:section heading="XML Escaping">
                    <p>
                        By default, special XML characters in the output of an expression
                        are always escaped to prevent <a href="http://en.wikipedia.org/wiki/Cross-site_scripting">cross-site scripting (XSS)</a> attacks.
                        For example, given the following template:
                    </p>
<docs:code-editor 
    mode="xml"
    readOnly="true" 
    c:parseBodyText="false"
><![CDATA[Hello $name]]></docs:code-editor>
                </docs:section>
                <p>
                    And the following data:
                </p>
<docs:code-editor 
    mode="javascript"
    readOnly="true" 
    c:parseBodyText="false"
><![CDATA[{
    "name": "<script>alert('Hello World')</script>"
}]]></docs:code-editor>
                <p>
                    The output would be the following:
                </p>
<docs:code-editor 
    mode="xml"
    readOnly="true"
><![CDATA[Hello ${entity:amp}lt;script${entity:amp}gt;alert('Hello World')${entity:amp}lt;/script${entity:amp}gt;!]]></docs:code-editor>
                <p>
                    In this example, the browser would not interpret the script tag
                    since the XML characters had been escaped.
                </p>
                <p c:parseBodyText="false">
                    To disable XML escaping, the expression should be of the form ${xml:<span>${entity:lt}</span>javascript-expression>}. 
                    The "xml" expression handler lets the compiler know that XML is
                    expected and that the XML characters should not be escaped.
                </p>
            </docs:section>
        
            <docs:section heading="Conditionals">
                <p>
                </p>
                
                <docs:section heading="if">
                    <p>
                        Any element or fragment of HTML can be made conditional using the c:if directive.
                    </p>
                    <table class="table table-bordered">
                        <thead>
                            <tr>
                                <th>
                                    Applied as an attribute
                                </th>
                                <th>
                                    Applied as an element
                                </th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td style="width: 50%">
<docs:code-editor 
    mode="xml"
    readOnly="true" 
    c:parseBodyText="false"
><![CDATA[<div c:if="someCondition">
    Hello World
</div>]]></docs:code-editor>
                                </td>
                                <td style="width: 50%">
<docs:code-editor 
    mode="xml"
    readOnly="true" 
    c:parseBodyText="false"
><![CDATA[<c:if test="someCondition">
    <div>
        Hello World
    </div>
</c:if>]]></docs:code-editor>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </docs:section>
                
                <docs:section
                    anchorName="ChooseWhenOtherwise"  
                    heading="choose…when…otherwise">
                    <p>
                        The c:choose directive, in combination with the directives c:when
                        and c:otherwise provides advanced conditional processing for
                        rendering one of several alternatives. The first matching c:when
                        branch is rendered, or, if no c:when branch matches, the c:otherwise
                        branch is rendered.
                    </p>
                    <table class="table table-bordered">
                        <thead>
                            <tr>
                                <th>
                                    Applied as an attribute
                                </th>
                                <th>
                                    Applied as an element
                                </th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td style="width: 50%">
<docs:code-editor 
    mode="xml"
    readOnly="true" 
    c:parseBodyText="false"
><![CDATA[<c:choose>
    <c:when test="myVar === 'A'">
        <div>A</div>
    </c:when>
    <c:when test="myVar === 'B'">
        <div>B</div>
    </c:when>
    <c:otherwise>
        <div>Something else</div>
    </c:otherwise>
<c:choose>]]></docs:code-editor>
                                </td>
                                <td style="width: 50%">
<docs:code-editor 
    mode="xml"
    readOnly="true" 
    c:parseBodyText="false"
><![CDATA[<c:choose>
    <div c:when="myVar === 'A'">
        A
    </div>
    <div c:when="myVar === 'B'">
        B
    </div>
    <div c:otherwise="">
        Something else
    </div>
<c:choose>]]></docs:code-editor>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <p>
                        Given a value of "A" for "myVar", the output would be the following:
                    </p>
<docs:code-editor 
    mode="xml"
    readOnly="true" 
    c:parseBodyText="false"
><![CDATA[<div>A</div>]]></docs:code-editor>
                    <p>
                        Given a value of "C" for "myVar", the output would be the following:
                    </p>
<docs:code-editor 
    mode="xml"
    readOnly="true" 
    c:parseBodyText="false"
><![CDATA[<div>Something else</div>]]></docs:code-editor>
                </docs:section>
                
            </docs:section>
            
            <docs:section heading="Looping">
                <docs:section heading="for">
                    <p>
                        Any element can be repeated for every item in an array using the
                        c:for directive. The directive can be applied as an element or as an
                        attribute.
                    </p>
                        <table class="table table-bordered">
                            <thead>
                                <tr>
                                    <th>
                                        Applied as an attribute
                                    </th>
                                    <th>
                                        Applied as an element
                                    </th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td style="width: 50%">
<docs:code-editor 
    mode="xml"
    readOnly="true" 
    c:parseBodyText="false"
><![CDATA[<ul>
    <li c:for="item in items">${item}</li>
</ul>]]></docs:code-editor>
                                    </td>
                                    <td style="width: 50%">
<docs:code-editor 
    mode="xml"
    readOnly="true" 
    c:parseBodyText="false"
><![CDATA[<ul>
    <c:for each="item in items">
        <li>${item}</li>
    </c:for>
</ul>]]></docs:code-editor>
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                        <p>
                            Given a value of <code>["red", "green", "blue"]</code> for 
                            <code>items</code>, the output would be the following:
                        </p>
<docs:code-editor 
    mode="xml"
    readOnly="true" 
    c:parseBodyText="false"
><![CDATA[<ul>
    <li>red</li>
    <li>green</li>
    <li>blue</li>
</ul>]]></docs:code-editor>
                    
                    <docs:section heading="Loop status variable">
                        <p>
                            If while looping you need access to additional information about the
                            status of the looping then the "varStatus" attribute can be
                            specified to introduce a new variable. The loop status variable
                            supports the following methods:
                        </p>
                        <ul>
                            <li>getLength()</li>
                            <li>isLast()</li>
                            <li>isFirst()</li>
                            <li>getIndex()</li>
                        </ul>
                        <table class="table table-bordered">
                            <thead>
                                <tr>
                                    <th>
                                        Applied as an attribute
                                    </th>
                                    <th>
                                        Applied as an element
                                    </th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td style="width: 50%">
<docs:code-editor 
    mode="xml"
    readOnly="true" 
    c:parseBodyText="false"
><![CDATA[<ul>
    <li c:for="item in items; varStatus=loopStatus">
        ${loopStatus.getIndex()+1}) ${item}
    </li>
</ul>]]></docs:code-editor>
                                    </td>
                                    <td style="width: 50%">
<docs:code-editor 
    mode="xml"
    readOnly="true" 
    c:parseBodyText="false"
><![CDATA[<ul>
    <c:for each="item in items" varStatus="loopStatus">
        <li>
            ${loopStatus.getIndex()+1}) ${item}
        </li>
    </c:for>
</ul>]]></docs:code-editor>
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                        <p>
                            Given a value of <code>["red", "green", "blue"]</code> for 
                            items, the output would be the following:
                        </p>
<docs:code-editor 
    mode="xml"
    readOnly="true" 
    c:parseBodyText="false"
><![CDATA[<ul>
    <li>
        1) red
    </li>
    <li>
        2) green
    </li>
    <li>
        3) blue
    </li>
</ul>]]></docs:code-editor>
                    </docs:section>
                    
                    <docs:section heading="Separator">
                        <p>
                        </p>
                    </docs:section>
                    
                </docs:section>
                
                
                
            </docs:section>
            
            <docs:section heading="Macros">
                <p>
                </p>
                
                <docs:section heading="def">
                    <p>
                    </p>
                    
                </docs:section>
                
                <docs:section heading="invoke">
                    <p>
                    </p>
                    
                </docs:section>
                
                
            </docs:section>
            
            <docs:section heading="Structure Manipulation">
                <p>
                </p>
                
                <docs:section heading="attrs">
                    <p>
                    </p>
                    
                </docs:section>
                
                <docs:section heading="bodyContent">
                    <p>
                    </p>
                    
                </docs:section>
                
                <docs:section heading="replace">
                    <p>
                    </p>
                    
                </docs:section>
                
                <docs:section heading="strip">
                    <p>
                    </p>
                    
                </docs:section>
                
            </docs:section>
            
        </docs:section>
        
        <docs:section heading="Taglibs">
            <p>
            </p>
            <docs:section heading="Runtime Tag Handlers">
                <p>
                </p>    
            </docs:section>
            
            <docs:section heading="Compile-Time Tag Handlers">
                <p>
                </p>    
            </docs:section>
            
            <docs:section heading="Helper Functions" anchorName="TaglibHelperFunctions">
                <p>
                </p>    
            </docs:section>
            
        </docs:section>
        
        <docs:section heading="JavaScript API">
            <p>
            </p>
            <docs:section heading="Template Rendering">
                <p>
                </p>
                <docs:section heading="Rendering to a String">
                    <p>
                    </p>    
                </docs:section>
                
                <docs:section heading="Rendering to a Context">
                    <p>
                    </p>    
                </docs:section>
                
            </docs:section>
            
            <docs:section heading="Template Compilation">
                <p>
                </p>
                <docs:section heading="Compiling a Template">
                    <p>
                    </p>    
                </docs:section>
                
                <docs:section heading="Loading a Compiled Template">
                    <p>
                    </p>    
                </docs:section>
                
            </docs:section>
        </docs:section>
        
        <docs:section heading="Side-By-Side Comparison">
            <p>
            </p>
            <docs:section heading="Raptor Template">
                <p>
                </p>

            </docs:section>
            
            <docs:section heading="Dust Template">
                <p>
                </p>

            </docs:section>
        </docs:section>
        
    </docs:docs>
    
</c:template>