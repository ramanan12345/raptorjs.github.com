<c:template
    xmlns:c="core"
    xmlns:docs="docs">

	<docs:docs heading="Modules and Classes">
		<docs:section heading="Modules">
<<<<<<< HEAD
			<p>
                RaptorJS modules are JavaScript objects with only static properties.
                In addition, a module is also treated as a collection of resource
                files (JavaScript, Less, CSS, Templates, etc.) that are packaged
                together for a module to work. It is also possible for a module to
                also include other modules, which brings its own dependencies.
            </p>
			<p>
                Let's take a look at singleton JS Module first, package module is
                dicussed later in this section. Unlike JavaScript classes, Raptor
                JavaScript modules are singleton objects. They have the following
                restrictions.
            </p>
            <ul>
=======
			<div class="para">RaptorJS modules are JavaScript objects with only static properties. In addition, a module is also treated as a collection of resource files (JavaScript, Less, CSS, Templates, etc.) that are packaged together for a module to work. It is also possible for a module to also include other modules, which brings its own dependencies.</div>
			<div class="para">Let's take a look at singleton JS Module first, package module is dicussed later in this section. Unlike JavaScript classes, Raptor JavaScript modules are singleton objects. They have the following restrictions.</div><ul>
>>>>>>> ce98de29fa8430705e2199463c7d80daba83d236
				<li>Modules cannot be used with the new keyword.</li>
				<li>Modules do not support inheritance.</li>
			</ul>
			<docs:section heading="Defining Modules">
				Use the following method to define raptor module:
				<docs:code-editor 
	                    autoResize="true"
	                    indentUnit="4"
	                    readOnly="true"
	                    mode="javascript"><![CDATA[raptor.define(moduleName, factoryFunction);]]></docs:code-editor>
<<<<<<< HEAD
	            <p>
                    <b>moduleName</b>:
                    This is a unique name for the module. By convention, dots or slashes should
                    be used to separate parts (for example:
                    <b>"utilities.strings.helpers"</b>).
                </p>
	            <p>
                    <b>factoryFunction</b>:
                    this should be a function that returns the definition of the module when
                    the module is initialized for the first time. As with defining
                    classes, the factory function provides a convenient closure to
                    support private variables and private functions. There are no
                    special properties of the module definition object and the returned
                    object directly becomes the singleton instance of the module.
                </p>
=======
	            <div class="para"><b>moduleName</b>: This is a unique name for the module. By convention, dots or slashes should be used to separate parts (for example: <b>"utilities.strings.helpers"</b>).</div>
	            <div class="para"><b>factoryFunction</b>: his should be a function that returns the definition of the module when the module is initialized for the first time. As with defining classes, the factory function provides a convenient closure to support private variables and private functions. There are no special properties of the module definition object and the returned object directly becomes the singleton instance of the module.</div>
>>>>>>> ce98de29fa8430705e2199463c7d80daba83d236
			</docs:section>
			<docs:section heading="Sample Example Code">
<docs:code-editor 
    autoResize="true"
    indentUnit="4"
    readOnly="true"
    mode="javascript"><![CDATA[raptor.define('some.namespace.myModule', function() {
	var SomeClass = raptor.require('some.namespace.SomeClass');
	
    return {
    
        someProperty: "Hello World",
        
        createSomeObject: function() {
            return new SomeClass();
        }
    }
});]]></docs:code-editor>		
			</docs:section>
			<docs:section heading="Directory Structure">
<<<<<<< HEAD
				<p>
                    Modules are packaged so that they can include any number of
                    JavaScripts and resources, and define their dependencies on other
                    modules. Because of these features, modules make it easy to expose
                    complex functionality that has been split across multiple JavaScript
                    files. Raptor JavaScript modules are similar in nature to CommonJS
                    modules.
                </p>
			    <p>
                    Every module must include a package.json file which provides
                    additional metadata for the module including the list of files that
                    should be included as part of the module. The module metadata
                    specifies the JavaScript resources resources that should be packaged
                    together as part of the module including which of the includes are
                    optional. The optional includes for a module are only included if
                    they are explicitly requested.
                </p>
				<p>
                    The module metadata also describes extensions for the module that
                    are only loaded if the extension is supported for the current page.
                    For example, a module may be extended with additional
                    jQuery-specific includes if the jQuery library is loaded.
				</p>
=======
				<div class="para">Modules are packaged so that they can include any number of JavaScripts and resources, and define their dependencies on other modules. Because of these features, modules make it easy to expose complex functionality that has been split across multiple JavaScript files. Raptor JavaScript modules are similar in nature to CommonJS modules.</div>
			    <div class="para">
				Every module must include a package.json file which provides additional metadata for the module including the list of files that should be included as part of the module. The module metadata specifies the JavaScript resources resources that should be packaged together as part of the module including which of the includes are optional. The optional includes for a module are only included if they are explicitly requested.</div>
				<div class="para">
				The module metadata also describes extensions for the module that are only loaded if the extension is supported for the current page. For example, a module may be extended with additional jQuery-specific includes if the jQuery library is loaded.
				</div>
>>>>>>> ce98de29fa8430705e2199463c7d80daba83d236
			</docs:section>
			<docs:section heading="Example package.json file">
<docs:code-editor 
        autoResize="true"
        indentUnit="4"
        readOnly="true"
        mode="javascript"><![CDATA[
{
    "name": "myModule",
    "version": "1.0",
    "description": "Description of your module",
    "homepage": "url for the module page",
    "authors": [
        {
            "name": "",
            "email": ""
        }
    ],
    "includes": [
        {"type": "module", "name": "myModule2"},
        {"type": "module", "name": "myModule3"},
        {"type": "js", "path": "myModuleClass.js"},
        {"type": "js", "path": "myModule.js"},
        {"type": "less", "path": "myModule.less"}
    ],
     
    "extensions": {
        "jquery": {
            "includes": [
                {"type": "js", "path": "Widget_jquery.js"}
            ]
        }
    }
}]]></docs:code-editor>		
			</docs:section>
		</docs:section>
		
		<docs:section heading="Classes">
			<p>Raptor classes Either of the following signatures can be used to define Raptor Class:</p>
			<ol>
			    <li>raptor.define(className, factoryFunction);</li>
			    <li>raptor.define(className, modifiers, factoryFunction);</li>
			</ol>
			<p>
			<ul>
			    <li><b>className:</b> The name of the class</li>
			    <li><b>modifiers:</b> (optional) set of modifiers, for example: "superclass"</li>
			    <li>
                    <b>factoryFunction:</b>
                    A function that returns the class definition when the class is
                    initialized for the first time. The factory function provides a
                    convenient closure to support private static variables and private
                    functions for your class (that is, no code outside the function can
                    directly reference the local variables of the function).
                </li>
			</ul>
			</p>
			<p>
                Classes support following modifiers:
            </p>
			<ul>
			    <li>superclass (string) - The name of the superclass (for example, "test.MySuperClass")</li>
			    <li>mixins (array) - An array of mixins to be applied to the class (see the "Class Mixins" section below)</li>
			</ul>
			
			
			<p>
                As you can see signature to define module and classes are same, only
                difference is the return object from the factory function. In case
                of module, it is a JavaScript object and in case of class, it will
                be a constructor function.
                It will be more clear from the examples below.
			</p>
			
			<docs:section heading="Example Class Definitions">
<<<<<<< HEAD
				<p><b>Simple Class</b></p>
=======
				<div class="para"><b>Simple Class</b></div>
>>>>>>> ce98de29fa8430705e2199463c7d80daba83d236
<docs:code-editor 
    autoResize="true"
    indentUnit="4"
    readOnly="true"
    mode="javascript"><![CDATA[
raptor.define(
    'some.namespace.MyClass',                      
    function() {   
        var privateProperty = "something";
        var privateMethod = function(){
            // some code
        };

        // Prototype function
        var MyClass = function() {
            // constructor function
        };
         
        MyClass.prototype = {
            init: function(){
                // init constructor
            },

            subMethod: function(){
                
            }
        };
         
        return MyClass;
    }
);]]></docs:code-editor>	
<<<<<<< HEAD
	            <p>
                    Above sample creates JavaScript class names
                    <b>some.namespace.MyClass</b>, defines a private property and method and function with
                    prototypes.
                </p>
	            <p>
                    If the class has "init" method defined, it will be used as a
                    constructor when new instace for the class is created otherwise main
                    function body will work as constructor.
	            </p>
			</docs:section>
			
			<docs:section heading="Inheritance">
				<p>
                    RaptorJS classes support prototypal-based inheritance. If a
                    "superclass" modifier is provided then the class will be configured
                    to extend the specified class by updating the prototype chain such
                    that the prototype of the newly created class will have as its
                    prototype and the prototype of the specified super class. 
				</p>
				<p>
                    If a superclass was specified and a constructor function was
                    returned by the factory function then a "superclass" property will
                    be added to the constructor function that points to the prototype of
                    the superclass. This property allows the subclass to reference
                    methods and properties in the superclass.
				</p>
				<p><b>Sample code</b></p>
=======
	            <div class="para">Above sample creates JavaScript class names <b>some.namespace.MyClass</b>, defines a private property and method and function with prototypes.</div>
	            <div class="para">If the class has "init" method defined, it will be used as a constructor when new instace for the class is created otherwise main function body
	            will work as constructor.
	            </div>
			</docs:section>
			
			<docs:section heading="Inheritance">
				<div class="para">
				    RaptorJS classes support prototypal-based inheritance. If a "superclass" modifier is provided then the class will be configured to extend the specified class by updating the prototype chain such that the prototype of the newly created class will have as its prototype and the prototype of the specified super class. 
				</div>
				<div class="para">
				If a superclass was specified and a constructor function was returned by the factory function then a "superclass" property will be added to the constructor function that points to the prototype of the superclass. This property allows the subclass to reference methods and properties in the superclass.
				</div>
				<div class="para"><b>Sample code</b></div>
>>>>>>> ce98de29fa8430705e2199463c7d80daba83d236
				<docs:code-editor 
	                    autoResize="true"
	                    indentUnit="4"
	                    readOnly="true"
	                    mode="javascript"><![CDATA[raptor.define(
    "some.namespace.MyClass},   
    {
    	superclass: "some.namespace.MySuperClass"
    },                
    function() {   
        var privateProperty = "something";
        var privateMethod = function(){
            // some code
        };
<<<<<<< HEAD

        // Prototype function
        var MyClass = function() {
            MyClass.superclass.constructor.apply(this, arguments);
        };
         
        MyClass.prototype = {

=======

        // Prototype function
        var MyClass = function() {
            MyClass.superclass.constructor.apply(this, arguments);
        };
         
        MyClass.prototype = {

>>>>>>> ce98de29fa8430705e2199463c7d80daba83d236
            subMethod: function(){
            	//Call a method in the superclass with arguments using the JavaScript call function
            	MyClass.superclass.superMethod.call(this, "hello", "world");
            	
            	//Alternatively, call a method in the superclass with arguments using the JavaScript apply function
                MyClass.superclass.superMethod.apply(this, arguments);
                
                //subMethod body code
            }
        };
         
        return MyClass;
    }
);]]></docs:code-editor>	
			</docs:section>
			<docs:section heading="Using Classes">
				Once a class has been defined it can easily be accessed using the following method:
<<<<<<< HEAD
				<p>raptor.require(className)</p>
				<p><b>Example Usage of Class Instantiation</b></p>
=======
				<div class="para">raptor.require(className)</div>
				<div class="para"><b>Example Usage of Class Instantiation</b></div>
>>>>>>> ce98de29fa8430705e2199463c7d80daba83d236
<docs:code-editor 
    autoResize="true"
    indentUnit="4"
    readOnly="true"
    mode="javascript"><![CDATA[
var MyClass = raptor.require("some.namespace.MyClass");
var myInstance = new MyClass();]]></docs:code-editor>
			</docs:section>
		</docs:section>
		<docs:section heading="Class Mixins">
			<p>
                Mixins are additional properties and methods that can be applied to
                the prototype of any class. Once a mixin has been defined with a
                name it can easily be applied to the prototype of a class (either as
                part of the class definition or using the raptor.extend(target,
                mixinName) method. Mixins are helpful when you have characteristics
                that can be applied to any class. For example, if a circular button
                has characteristics of a circle, the circle mixin could be applied
                to the circular button.
            </p>
			<p>
                Because using mixins do not modify the prototype-chain, using mixins
                is very different from using inheritance. For more details on
                mixins, see the <a href="http://en.wikipedia.org/wiki/Mixin" target="_blank">Wikipedia: Mixin article.</a>
            </p>
		
			<docs:section heading="Defining Mixins">
				The following method should be used to define mixins:
				<p>
                    raptor.defineMixin(mixinName, factoryFunction);
                </p>
				<p>
                    <b>mixinName</b>: This is a reference to the raptor object
                </p>
				<p>
                    <b>factoryFunction</b>:
                    Function that returns the definition of the mixin when the mixin is initialized
                    for the first time. The factory function provides a convenient
                    closure to support private static variables and private functions
                    for your class (that is, no code outside the function can directly
                    reference the local variables of the function).
                    The return value of the factory function should be an object that defines
                    the mixin. The properties of the returned object become properties
                    of the prototype of any class that the mixin is applied to unless
                    the property is the mixinModifiers property described below.
				</p>
			</docs:section>
			
			<docs:section heading="Example Mixin Definitions">
<docs:code-editor 
    autoResize="true"
    indentUnit="4"
    readOnly="true"
    mode="javascript"><![CDATA[raptor.defineMixin(
    'some.namespace.Rectangle',
    function() {
 
        return {
            setDimensions: function(width, height) {
                this.width = width;
                this.height = height;
            },
             
            getArea: function() {
                return this.width * this.height;
            }
        }
    }
);]]></docs:code-editor>
			</docs:section>
			
			<docs:section heading="Using Mixins">
<<<<<<< HEAD
				<p><b>Applying mixins as Part of the Definition of a Class</b></p>
=======
				<div class="para"><b>Applying mixins as Part of the Definition of a Class</b></div>
>>>>>>> ce98de29fa8430705e2199463c7d80daba83d236
<docs:code-editor 
    autoResize="true"
    indentUnit="4"
    readOnly="true"
    mode="javascript"><![CDATA[raptor.defineClass(
    'some.namespace.MyClass',
    {
        mixins: ['some.namespace.MyMixin',
                 'another.namespace.AnotherMixin']
    },
    function() {
        return {
            //Class prototype
        };
    }
);]]></docs:code-editor>
	            
	            <p><b>Applying mixins to an Object Manually</b></p>
	            <p>
                    Once a mixin has been defined it can be applied to a class as part
                    of the definition of a class. You can also apply mixins manually by
                    using the raptor.extend(target, mixinName) function.
                </p>
				<p>raptor.extend(MyClass.prototype, 'some.namespace.Rectangle')</p>
			</docs:section>
			
<<<<<<< HEAD
			<docs:section heading="Invoking Overridden Methods">
                <p>
                    If a mixin contains a property that overrides a function in the
                    original prototype,
                    the mixin should be created using a createMixin method that returns the
                    mixins.
                    The createMixin method will be invoked by Raptor with an overridden
                    parameter that is given references to any of the methods that were
                    overridden
                    in the class to which the mixins are applied. That is, if a method in the
                    mixin returned by the createMixin method has the same name as a
                    method in the target object to which the mixin is being, the
                    overridden object supplied as the first argument to the createMixin
                    method will then be populated with a reference to the overridden
                    function.
                    The overridden method can then be invoked using the native JavaScript
                    apply function or the native JavaScript call function.
                </p>
                <p> 
				    For example:
                </p>
=======
			<docs:section heading="Calling Overridden Methods in the Target Object">
				If a mixin contains a property that overrides a function in the original prototype, 
				the mixin should be created using a createMixin method that returns the mixins. 
				The createMixin method will be invoked by Raptor with an overridden parameter that is given references to any of the methods that were overridden 
				in the class to which the mixins are applied. That is, if a method in the mixin returned by the createMixin method has the same name as a method in the target object to which the mixin is being, the overridden object supplied as the first argument to the createMixin method will then be populated with a reference to the overridden function. 
				The overridden method can then be invoked using the native JavaScript apply function or the native JavaScript call function. 
				For example:
>>>>>>> ce98de29fa8430705e2199463c7d80daba83d236
<docs:code-editor 
    autoResize="true"
    indentUnit="4"
    readOnly="true"
    mode="javascript"><![CDATA[raptor.defineMixin(
    'some.namespace.MyMixin',
<<<<<<< HEAD
    function(raptor, target, overridden)
    {
        return {
            myMixinMethod: function(arg1, arg2, ...) {
                //Invoke the method that was overridden by this mixin method using the same arguments that were used to invoke this method
                overridden.myMixinMethod.apply(this, arguments);
            }
        };
=======
    {
        createMixin: function(overridden) {
            return {
                myMixinMethod: function(arg1, arg2, ...) {
                    //Invoke the method that was overridden by this mixin method using the same arguments that were used to invoke this method
                    overridden.myMixinMethod.apply(this, arguments);
                }
            };
        }
>>>>>>> ce98de29fa8430705e2199463c7d80daba83d236
    }
);]]></docs:code-editor>
			</docs:section>
			
		</docs:section>
		
		<docs:section heading="Enums">
<<<<<<< HEAD
            <p>
                Similar to Java enums, RaptorJS enums provide a way to define
                constants. Each enum value is an instance of a JavaScript class that
                can have a constructor, methods, and properties.
            </p>
		    <docs:section heading="Defining an Enum">
=======
		    Similar to Java enums, RaptorJS enums provide a way to define constants. Each enum value is an instance of a JavaScript class that can have a constructor, methods, and properties.
		    <docs:section heading="Defining a Raptor enum">
>>>>>>> ce98de29fa8430705e2199463c7d80daba83d236
		        Use the following method to define an enum.
		        <p>raptor.defineEnum(enumName, enumValues, factoryFunction);</p>
		        <p>
                    The enumValues argument can be an array of strings that define the
                    constant fields, or it can be a map. If the enumValues argument is a
                    map, the keys correspond to the names of the constant fields and the
                    value should be an array of arguments to pass to the constructor and
                    a factoryFunction must be provided and it must define the class.
                </p>
		    </docs:section>
		    
<<<<<<< HEAD
		    <docs:section heading="Example Enum Definitions">
		        <p><b>Simple enum</b></p>
=======
		    <docs:section heading="Example enum Definitions">
		        <div class="para"><b>Simple enum</b></div>
>>>>>>> ce98de29fa8430705e2199463c7d80daba83d236
<docs:code-editor 
    autoResize="true"
    indentUnit="4"
    readOnly="true"
    mode="javascript"><![CDATA[raptor.defineEnum(
    'some.namespace.Day',
    [
        "SUN",
        "MON",
        "TUE",
        "WED",
        "THU",
        "FRI",
        "SAT"
    ]
);]]></docs:code-editor>
		        
		        <p><b>Complex enum with a constructor, properties and methods</b></p>
		        <docs:code-editor 
		                autoResize="true"
		                indentUnit="4"
		                readOnly="true"
		                mode="javascript"><![CDATA[raptor.defineEnum(
    'some.namespace.Day',
    {
        SUN: [false, "Sunday"],
        MON: [true, "Monday"],
        TUE: [true, "Tuesday"],
        WED: [true, "Wednesday"],
        THU: [true, "Thursday"],
        FRI: [true, "Friday"],
        SAT: [false, "Saturday"]
    },
    function(raptor, type) {
        return {
            init: function(isWeekday, longName) {
                this._isWeekday = isWeekday;
                this._longName = longName;
            },
             
            getLongName: function() {
                return this._longName;
            },
             
            isWeekday: function() {
                return this._isWeekday;
            }
        }
    }
);]]></docs:code-editor>
		    </docs:section>
		    
		    <docs:section heading="Enum Methods">
		        <p>Every enum class supports the following methods.</p>
		        <ul>
		            <li>valueOf(name) - Returns the constant field with the same name (case sensitive)</li>
		        </ul>
		        <p>Every enum field supports the following methods.</p>
		        <ul>
		            <li>
                        name() - Returns the name of the enum
                    </li>
		            <li>
                        ordinal() - Returns the positional value of the enum (NOTE: This
                        should only be used for an array of enum strings. Order is undefined
                        for maps but it will work correctly in most browsers.)
                    </li>
		            <li>
                        toString() - Returns the name of the enum unless it has been overridden
                    </li>
		            <li>
                        compareTo(other) - Compares one enum field to another based on the ordinal value
                    </li>
		        </ul>
		    </docs:section>
		    
<<<<<<< HEAD
		    <docs:section heading="Enum Usage">
                <p>
                    Once you define an enum, the enum constants can be accessed as
                    static properties of the class as shown in the following example.
                </p>
=======
		    <docs:section heading="enum Methods">
		        Once you define an enum, the enum constants can be accessed as static properties of the class as shown in the following example.
>>>>>>> ce98de29fa8430705e2199463c7d80daba83d236
<docs:code-editor 
    autoResize="true"
    indentUnit="4"
    readOnly="true"
    mode="javascript"><![CDATA[var Day = raptor.require('some.namespace.Day');
if (day === Day.FRI) {
    alert("It is " + day.getLongName() + "!");
}]]></docs:code-editor>
		    </docs:section>
		</docs:section>
	</docs:docs>
</c:template>