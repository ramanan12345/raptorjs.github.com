<c:template
    xmlns:c="core"
    xmlns:docs="docs">

	<docs:docs heading="Modules and Classes">
		<docs:section heading="Modules">
			<div class="para">Raptor JavaScript modules are JavaScript classes with only static properties. In addition, a module is also treated as a collection of resource files (JavaScript, Less, CSS, Templates, etc.) that are packaged together for a module to work. It is also possible for a module to also include other modules, which brings its own dependencies.</div>
			<div class="para">Let's take a look at singleton JS Module first, package module is dicussed later in this section. Unlike JavaScript classes, Raptor JavaScript modules are singleton objects. They have the following restrictions.</div><ul>
				<li>Modules cannot be used with the new keyword.</li>
				<li>Modules do not support inheritance.</li>
			</ul>
			<docs:section heading="Defining Raptor JavaScript Modules">
				Use the following method to define raptor module:
				<docs:code-editor 
	                    autoResize="true"
	                    indentUnit="4"
	                    readOnly="true"
	                    mode="xml">
	            
		            <![CDATA[
		            	raptor.define(moduleName, factoryFunction);
		            ]]>
	            </docs:code-editor>
	            <div class="para"><b>moduleName</b>: This is a unique name for the module. By convention, dots or slashes should be used to separate parts (for example: <b>"utilities.strings.helpers"</b>).</div>
	            <div class="para"><b>factoryFunction</b>: his should be a function that returns the definition of the module when the module is initialized for the first time. As with defining classes, the factory function provides a convenient closure to support private variables and private functions. There are no special properties of the module definition object and the returned object directly becomes the singleton instance of the module.</div>
			</docs:section>
			<docs:section heading="Sample Example Code">
				<docs:code-editor 
	                    autoResize="true"
	                    indentUnit="4"
	                    readOnly="true"
	                    mode="xml">
	            
		            <![CDATA[
		            	raptor.define('some.namespace.myModule', function() {
		    				var SomeClass = raptor.require('some.namespace.SomeClass');
		    				
						    return {
						    
						        someProperty: "Hello World",
						        
						        createSomeObject: function() {
						            return new SomeClass();
						        }
						    }
						});
		            ]]>
	            </docs:code-editor>		
			</docs:section>
			<docs:section heading="Module Directory Structure and Metadata">
				<div class="para">Modules are packaged so that they can include any number of JavaScripts and resources, and define their dependencies on other modules. Because of these features, modules make it easy to expose complex functionality that has been split across multiple JavaScript files. Raptor JavaScript modules are similar in nature to CommonJS modules.</div>
			    <div class="para">
				Every module must include a package.json file which provides additional metadata for the module including the list of files that should be included as part of the module. The module metadata specifies the JavaScript resources resources that should be packaged together as part of the module including which of the includes are optional. The optional includes for a module are only included if they are explicitly requested.</div>
				<div class="para">
				The module metadata also describes extensions for the module that are only loaded if the extension is supported for the current page. For example, a module may be extended with additional jQuery-specific includes if the jQuery library is loaded.
				</div>
			</docs:section>
			<docs:section heading="Example package.json file">
				<docs:code-editor 
	                    autoResize="true"
	                    indentUnit="4"
	                    readOnly="true"
	                    mode="xml">
	            
		            <![CDATA[
		            	{
						    "name": "myModule",
						    "version": "1.0",
						    "description": "Description of your module",
						    "homepage": "url for the module page",
						    "authors": [
						        {
						            "name": "",
						            "email": ""
						        }
						    ],
						    "includes": [
						        {"type": "module", "name": "myModule2"},
						        {"type": "module", "name": "myModule3"},
						        {"type": "js", "path": "myModuleClass.js"},
						        {"type": "js", "path": "myModule.js"},
						        {"type": "less", "path": "myModule.less"}
						    ],
						     
						    "extensions": {
						        "jquery": {
						            "includes": [
						                {"type": "js", "path": "Widget_jquery.js"}
						            ]
						        }
						    }
						}
		            ]]>
	            </docs:code-editor>		
			</docs:section>
		</docs:section>
		
		<docs:section heading="Classes">
			<div class="para">Raptor classes Either of the following signatures can be used to define Raptor Class:</div>
			<ol>
			    <li>raptor.define(className, factoryFunction);</li>
			    <li>raptor.define(className, modifiers, factoryFunction);</li>
			</ol>
			<div class="para">
			<ul>
			    <li><b>className:</b> The name of the class</li>
			    <li><b>modifiers:</b> (optional) set of modifiers, for example: "superclass"</li>
			    <li><b>factoryFunction:</b> A function that returns the class definition when the class is initialized for the first time. The factory function provides a convenient closure to support private static variables and private functions for your class (that is, no code outside the function can directly reference the local variables of the function).</li>
			</ul>
			</div>
			<div class="para">Classes support following modifiers:
			<ul>
			    <li>superclass (string) - The name of the superclass (for example, "test.MySuperClass")</li>
			    <li>mixins (array) - An array of mixins to be applied to the class (see the "Class Mixins" section below)</li>
			</ul>
			</div>
			
			<div class="para">
			    As you can see signature to define module and classes are same, only difference is the return object from the factory function. In case of module, it is a JavaScript object and in case of class, it will be a constructor function.
			    It will be more clear from the examples below.
			</div>
			
			<docs:section heading="Example Class Definitions">
				<div class="para"><b>Simple Class</b></div>
				<docs:code-editor 
	                    autoResize="true"
	                    indentUnit="4"
	                    readOnly="true"
	                    mode="xml">
	            
		            <![CDATA[
		            	raptor.define(
						    'some.namespace.MyClass',                      
						    function() {   
						        var privateProperty = "something";
						        var privateMethod = function(){
						            // some code
						        };
						
						        // Prototype function
						        var MyClass = function() {
						            // constructor function
						        };
						         
						        MyClass.prototype = {
						            init: function(){
						                // init constructor
						            },
						
						            subMethod: function(){
						                
						            }
						        };
						         
						        return MyClass;
						    }
						);
		            ]]>
	            </docs:code-editor>	
	            <div class="para">Above sample creates JavaScript class names <b>some.namespace.MyClass</b>, defines a private property and method and function with prototypes.</div>
	            <div class="para">If the class has "init" method defined, it will be used as a constructor when new instace for the class is created otherwise main function body
	            will work as constructor.
	            </div>
			</docs:section>
			
			<docs:section heading="Inheritance">
				<div class="para">
				    Raptor JavaScript classes support prototypal-based inheritance. If a "superclass" modifier is provided then the class will be configured to extend the specified class by updating the prototype chain such that the prototype of the newly created class will have as its prototype and the prototype of the specified super class. 
				</div>
				<div class="para">
				If a superclass was specified and a constructor function was returned by the factory function then a "superclass" property will be added to the constructor function that points to the prototype of the superclass. This property allows the subclass to reference methods and properties in the superclass.
				</div>
				<div class="para"><b>Sample code</b></div>
				<docs:code-editor 
	                    autoResize="true"
	                    indentUnit="4"
	                    readOnly="true"
	                    mode="xml">
	            
		            <![CDATA[
		            	raptor.define(
						    'some.namespace.MyClass',   
						    {
						    	superclass: "'some.namespace.MySuperClass'"
						    },                
						    function() {   
						        var privateProperty = "something";
						        var privateMethod = function(){
						            // some code
						        };
						
						        // Prototype function
						        var MyClass = function() {
						            MyClass.superclass.constructor.apply(this, arguments);
						        };
						         
						        MyClass.prototype = {

						            subMethod: function(){
						            	//Call a method in the superclass with arguments using the JavaScript call function
						            	MyClass.superclass.superMethod.call(this, "hello", "world");
						            	
						            	//Alternatively, call a method in the superclass with arguments using the JavaScript apply function
						                MyClass.superclass.superMethod.apply(this, arguments);
						                
						                //subMethod body code
						            }
						        };
						         
						        return MyClass;
						    }
						);
		            ]]>
	            </docs:code-editor>	
			</docs:section>
			<docs:section heading="Using Raptor JavaScript Classes">
				Once a class has been defined it can easily be accessed using the following method:
				<div class="para">raptor.require(className)</div>
				<div class="para"><b>Example Usage of Class Instantiation</b></div>
				<docs:code-editor 
	                    autoResize="true"
	                    indentUnit="4"
	                    readOnly="true"
	                    mode="xml">
	            
		            <![CDATA[
		            	var MyClass = raptor.require("some.namespace.MyClass");
						var myInstance = new MyClass();
		            ]]>
	            </docs:code-editor>
			</docs:section>
		</docs:section>
		<docs:section heading="Class Mixins">
			<div class="para">Mixins are additional properties and methods that can be applied to the prototype of any class. Once a mixin has been defined with a name it can easily be applied to the prototype of a class (either as part of the class definition or using the raptor.extend(target, mixinName) method. Mixins are helpful when you have characteristics that can be applied to any class. For example, if a circular button has characteristics of a circle, the circle mixin could be applied to the circular button.</div>
			<div class="para">Because using mixins do not modify the prototype-chain, using mixins is very different from using inheritance. For more details on mixins, see the <a href="http://en.wikipedia.org/wiki/Mixin" target="_blank">Wikipedia: Mixin article.</a></div>
		
			<docs:section heading="Defining Raptor Mixins">
				The following method should be used to define mixins:
				<div class="para">raptor.defineMixin(mixinName, factoryFunction);</div>
				<div class="para"><b>mixinName</b>: This is a reference to the raptor object</div>
				<div class="para"><b>factoryFunction</b>: Function that returns the definition of the mixin when the mixin is initialized for the first time. The factory function provides a convenient closure to support private static variables and private functions for your class (that is, no code outside the function can directly reference the local variables of the function).
				The return value of the factory function should be an object that defines the mixin. The properties of the returned object become properties of the prototype of any class that the mixin is applied to unless the property is the mixinModifiers property described below.
				</div>
			</docs:section>
			
			<docs:section heading="Example Mixin Definitions">
				<docs:code-editor 
	                    autoResize="true"
	                    indentUnit="4"
	                    readOnly="true"
	                    mode="xml">
	            
		            <![CDATA[
		            	raptor.defineMixin(
						    'some.namespace.Rectangle',
						    function() {
						 
						        return {
						            setDimensions: function(width, height) {
						                this.width = width;
						                this.height = height;
						            },
						             
						            getArea: function() {
						                return this.width * this.height;
						            }
						        }
						    }
						);
		            ]]>
	            </docs:code-editor>
			</docs:section>
			
			<docs:section heading="Using Mixins">
				<div class="para"><b>Applying mixins as Part of the Definition of a Class</b></div>
				<docs:code-editor 
	                    autoResize="true"
	                    indentUnit="4"
	                    readOnly="true"
	                    mode="xml">
	            
		            <![CDATA[
		            	raptor.defineClass(
						    'some.namespace.MyClass',
						    {
						        mixins: ['some.namespace.MyMixin',
						                 'another.namespace.AnotherMixin']
						    },
						    function() {
						        return {
						            //Class prototype
						        };
						    }
						);
		            ]]>
	            </docs:code-editor>
	            
	            <div class="para"><b>Applying mixins to an Object Manually</b></div>
	            <div class="para">Once a mixin has been defined it can be applied to a class as part of the definition of a class. You can also apply mixins manually by using the raptor.extend(target, mixinName) function.</div>
				<div class="para">raptor.extend(MyClass.prototype, 'some.namespace.Rectangle')</div>
			</docs:section>
			
			<docs:section heading="Calling Overridden Methods in the Target Object">
				If a mixin contains a property that overrides a function in the original prototype, 
				the mixin should be created using a createMixin method that returns the mixins. 
				The createMixin method will be invoked by Raptor with an overridden parameter that is given references to any of the methods that were overridden 
				in the class to which the mixins are applied. That is, if a method in the mixin returned by the createMixin method has the same name as a method in the target object to which the mixin is being, the overridden object supplied as the first argument to the createMixin method will then be populated with a reference to the overridden function. 
				The overridden method can then be invoked using the native JavaScript apply function or the native JavaScript call function. 
				For example:
				<docs:code-editor 
	                    autoResize="true"
	                    indentUnit="4"
	                    readOnly="true"
	                    mode="xml">
	            
		            <![CDATA[
		            	raptor.defineMixin(
					        'some.namespace.MyMixin',
					        {
					            createMixin: function(overridden) {
					                return {
					                    myMixinMethod: function(arg1, arg2, ...) {
					                        //Invoke the method that was overridden by this mixin method using the same arguments that were used to invoke this method
					                        overridden.myMixinMethod.apply(this, arguments);
					                    }
					                };
					            }
					        }
					    );
		            ]]>
	            </docs:code-editor>
			</docs:section>
			
		</docs:section>
		
		<docs:section heading="Enums">
		    Similar to Java enum, Raptor JavaScript enum provides a way to define constants. Each enum value is an instance of a JavaScript class that can have a constructor, methods, and properties.
		    <docs:section heading="Defining a Raptor enum">
		        Use the following method to define an enum.
		        <div class="para">raptor.defineEnum(enumName, enumValues, factoryFunction);</div>
		        <div class="para">The enumValues argument can be an array of strings that define the constant fields, or it can be a map. If the enumValues argument is a map, the keys correspond to the names of the constant fields and the value should be an array of arguments to pass to the constructor and a factoryFunction must be provided and it must define the class.</div>
		    </docs:section>
		    
		    <docs:section heading="Example enum Definitions">
		        <div class="para"><b>Simple enum</b></div>
		        <docs:code-editor 
		                autoResize="true"
		                indentUnit="4"
		                readOnly="true"
		                mode="xml">
		        
		            <![CDATA[
		                raptor.defineEnum(
		                    'some.namespace.Day',
		                    [
		                        "SUN",
		                        "MON",
		                        "TUE",
		                        "WED",
		                        "THU",
		                        "FRI",
		                        "SAT"
		                    ]
		                );
		            ]]>
		        </docs:code-editor>
		        
		        <div class="para"><b>Complex enum with a constructor, properties and methods</b></div>
		        <docs:code-editor 
		                autoResize="true"
		                indentUnit="4"
		                readOnly="true"
		                mode="xml">
		        
		            <![CDATA[
		                raptor.defineEnum(
		                    'some.namespace.Day',
		                    {
		                        SUN: [false, "Sunday"],
		                        MON: [true, "Monday"],
		                        TUE: [true, "Tuesday"],
		                        WED: [true, "Wednesday"],
		                        THU: [true, "Thursday"],
		                        FRI: [true, "Friday"],
		                        SAT: [false, "Saturday"]
		                    },
		                    function(raptor, type) {
		                        return {
		                            init: function(isWeekday, longName) {
		                                this._isWeekday = isWeekday;
		                                this._longName = longName;
		                            },
		                             
		                            getLongName: function() {
		                                return this._longName;
		                            },
		                             
		                            isWeekday: function() {
		                                return this._isWeekday;
		                            }
		                        }
		                    }
		                );
		            ]]>
		        </docs:code-editor>
		    </docs:section>
		    
		    <docs:section heading="enum Methods">
		        <div class="para">Every enum class supports the following methods.</div>
		        <ul>
		            <li>valueOf(name) - Returns the constant field with the same name (case sensitive)</li>
		        </ul>
		        <div class="para">Every enum field supports the following methods.</div>
		        <ul>
		            <li>name() - Returns the name of the enum</li>
		            <li>ordinal() - Returns the positional value of the enum (NOTE: This should only be used for an array of enum strings. Order is undefined for maps but it will work correctly in most browsers.)</li>
		            <li>toString() - Returns the name of the enum unless it has been overridden</li>
		            <li>compareTo(other) - Compares one enum field to another based on the ordinal value</li>
		        </ul>
		    </docs:section>
		    
		    <docs:section heading="enum Methods">
		        Once you define an enum, the enum constants can be accessed as static properties of the class as shown in the following example.
		        <docs:code-editor 
		                autoResize="true"
		                indentUnit="4"
		                readOnly="true"
		                mode="xml">
		        
		            <![CDATA[
		                var Day = raptor.require('some.namespace.Day');
		                if (day === Day.FRI) {
		                    alert("It is " + day.getLongName() + "!");
		                }
		            ]]>
		        </docs:code-editor>
		    </docs:section>
		</docs:section>
	</docs:docs>
</c:template>